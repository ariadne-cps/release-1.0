/***************************************************************************
 *            tutorial.dox
 *
 *  Copyright  2014  Luca Geretti
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*!

\file tutorial.dox
\brief Tutorial on %Ariadne's features.

\page tutorial_page Tutorial

\dontinclude tutorial.cc

In this tutorial, we show how to use %Ariadne to model and analyse a hybrid automaton model of a water tank system.

The tutorial files can be found in the \em tutorial directory of the distribution. 

More specifically, the tutorial focuses on one hybrid system, described with increasing level of detail: 

 - \link tutorial/monolithic-forced.h monolithic-forced.h \endlink: a monolithic version of the system, where
all transitions are forced; 
 - \link tutorial/monolithic.h monolithic.h \endlink: the
monolithic system has both forced and unforced transitions;
 - \link tutorial/compositional.h compositional.h \endlink: the system, featuring unforced transitions, is expressed as a composition of subsystems.

While the compositional version may be regarded as the most intuitive way to describe the system, we believe that
comparing the monolithic and compositional versions is still relevant, especially due to numerical issues that may
arise during the analysis of the compositional case.

For each of these three variants, some analysis routines are performed. The analysis part is common and it is contained 
within the file \link tutorial/analysis.h analysis.h \endlink. The source files for the executables instead are given by
\link tutorial/monolithic-forced.cc monolithic-forced.cc \endlink, \link tutorial/monolithic.cc monolithic.cc \endlink 
and \link tutorial/compositional.cc compositional.cc \endlink, respectively.

\section tutorial_system_model The Hybrid Automaton Model

The automaton represents a hydrodynamic system composed of a tank, a valve and a controller for the valve. In particular, the controller changes the aperture of the valve based on the current water level, with the purpose of keeping the level within two thresholds. 

The system has two discrete modes, \f$\textsc{On}\f$ and \f$\textsc{Off}\f$, representing the state of the heater. There are three events, \f$\textsc{TurnOn}\f$, \f$\textsc{TurnOff}\f$ and \f$\textsc{Midnight}\f$; the first two representing switching the heater, and the last being a reset of the clock at the beginning of a new day.

The system has two continuous variables, \em temperature \f$T\f$ and \em time-of-day \f$\tau\f$.
The system is described by three parameters, the heater power \f$H\f$, the insulation level \f$K\f$, the average external temperature \f$T_E\f$, the amplitude of the temperature fluctuations \f$T_A\f$.

\f[ \dot{T} = H + K(T_E + T_A\cos(2\pi t) - T); \quad \dot{t}=1. \f]

The heater is turned on whenever the temperature falls below \f$T_{\textsc{On}}\f$, and is turned off whenever the temperature rises above \f$T_{\textsc{Off}}\f$.



\section tutorial_building_system Building the Ariadne Hybrid Automaton

First, choose an ordering for the parameters and variables in each mode.
In this example, the same parameters and variables are used in each mode, so this is easy.

\skipline // System variables
\until p[6]

Now define the nonlinear functions used in the system definition.

\skipline // System dynamic
\until };
\until };

Next define the function creating the system.

\skipline create_
\until {

Create the HybridAutomaton object.

\skipline //
\until HybridAutomaton

Set the system parameters.

\skipline //
\until Ton_lower

Define the discrete states and discrete events.

\skipline //
\until heater_off
\until midnight

Create the nonlinear system dynamics.

\skipline //
\until heater_off_dynamic

Create the affine reset maps. Note that an affine function has the form \f$x\mapsto Ax+b\f$.

\skipline //
\until midnight_reset

Create the affine guard functions. Note that continuous dynamics is possible when \f$g(x)\leq0\f$, and discrete transitions are possible for \f$g(x)\geq0\f$.

\skipline //
\until midnight_guard

Create the system modes.

\skipline //
\until heater_off_dynamic

Create the system transitions

\skipline //
\until heater_turn_off_guard
\until heater_off


End of function

\skipline }



\section tutorial_hybrid_system_evolution Computing the Continuous Evolution

The following function creates a HybridEvolver object, which is a class which can compute system evolution.

\skipline create_evolver
\until }

We now compute the evolution of the system.
\skipline compute_evolution
\until {

Define the intial set and evolution time.

\skipline // Define the initial set
\until evolution_time

Compute the reachable and evolved sets.

\skipline evolver.reach_evolve

Compute the trajectories parameterised by time.

\skipline evolver.orbit

Write the sets to standard output and to a file.

\skipline write
\skipline plot

End of function

\skipline }



\section tutorial_hybrid_system_reachability Computing Reachable Sets

\skipline compute_reachable_sets
\until {

Create a ReachabilityAnalyser object.

\skipline analyser

Set the initial set.

\skipline initial_set
\until initial_set[

Set the evolution time.
\skipline reach_time

Compute lower-approximation to the finite-time evolved set.

\skipline lower_evolve
\skipline plot

Compute lower-approximation to the finite-time reachable set.

\skipline lower_reach

Compute over-approximation to the finite-time evolved set.

\skipline upper_evolve

Compute over-approximation to the finite-time reachable set.

\skipline upper_reach

Compute over-approximation to the infinite-time chain-reachable set.

\skipline chain_reach

End of function.

\skipline }

\section tutorial_main Main function

\skipline main(
\skipline {
\skipline // Create
\until }
*/

